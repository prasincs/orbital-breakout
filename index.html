
<!-- index.html -->
<!DOCTYPE html>
<html>
<head>
  <title>Orbit Breakout</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
  <style>
    body { margin: 0; display: flex; justify-content: center; align-items: center; height: 100vh; background-color: #1a1a1a; }
    canvas { border: 2px solid #fff; }
  </style>
</head>
<body>
  <script>
    let paddle;
    let mainBall;
    let orbitingBalls = [];
    let score = 0;
    let turns = 0;
    let gameStarted = false;
    let aimAngle = -Math.PI/4; // Start aiming up-right
    let bricks = [];
    
    function setup() {
      createCanvas(600, 400);
      paddle = new Paddle();
      mainBall = new Ball();
      mainBall.isMain = true;
      initializeBricks();
    }

    function draw() {
      background(30);
      paddle.show();
      paddle.move();
      
      // Draw aiming line if game not started
      if (!gameStarted) {
        stroke(255);
        strokeWeight(2);
        let lineLength = 100;
        line(mainBall.x, mainBall.y, 
             mainBall.x + cos(aimAngle) * lineLength, 
             mainBall.y + sin(aimAngle) * lineLength);
        strokeWeight(1);
        noStroke();
        
        // Adjust aim angle with arrow keys
        if (keyIsDown(LEFT_ARROW)) aimAngle -= 0.05;
        if (keyIsDown(RIGHT_ARROW)) aimAngle += 0.05;
        // Clamp angle to reasonable range (upward directions)
        aimAngle = constrain(aimAngle, -PI, 0);
      }
      
      // Handle all balls
      mainBall.show();
      if (gameStarted) {
        mainBall.move();
        mainBall.bounce();
      } else {
        // Position ball on paddle before launch
        mainBall.x = paddle.x + paddle.w/2;
        mainBall.y = paddle.y - mainBall.r;
      }
      
      // Handle orbiting balls
      for (let i = orbitingBalls.length - 1; i >= 0; i--) {
        orbitingBalls[i].show();
        if (gameStarted) {
          orbitingBalls[i].move();
          orbitingBalls[i].bounce();
        } else {
          // When not started, orbiting balls stay with main ball
          orbitingBalls[i].x = mainBall.x;
          orbitingBalls[i].y = mainBall.y;
        }
      }
      
      // Show bricks
      for (let brick of bricks) {
        brick.show();
      }
      
      // Check ball-brick collisions
      checkBrickCollisions();

      // Display score and turns
      fill(255);
      textSize(16);
      text(`Score: ${score}`, 10, 20);
      text(`Turns: ${turns}`, 10, 40);
      
      // Instructions
      if (!gameStarted) {
        textAlign(CENTER);
        text("Use LEFT/RIGHT arrows to aim, SPACE to launch", width/2, height - 50);
        textAlign(LEFT);
      }
    }

    function keyPressed() {
      if (keyCode === 32 && !gameStarted) { // Space bar
        gameStarted = true;
        mainBall.dx = cos(aimAngle) * 5;
        mainBall.dy = sin(aimAngle) * 5;
        
        // Launch orbiting balls too
        for (let ball of orbitingBalls) {
          ball.dx = mainBall.dx + random(-0.5, 0.5);
          ball.dy = mainBall.dy + random(-0.5, 0.5);
        }
      }
    }

    function initializeBricks() {
      bricks = []; // Clear existing bricks
      let types = ['green', 'pink', 'blue'];
      let hitPoints = { 'green': 34, 'pink': 26, 'blue': 14 };
      
      for (let x = 50; x < width - 50; x += 60) {
        for (let y = 50; y < 150; y += 30) {
          // Random chance to place a brick (70%)
          if (random() < 0.7) {
            let type = random(types);
            let hp = hitPoints[type];
            bricks.push(new Brick(x + 25, y + 10, hp, type));
          }
        }
      }
    }

    function addOrbitingBall() {
      let newBall = new Ball(mainBall.x, mainBall.y, true);
      newBall.isOrbiting = true;
      newBall.orbitDistance = random(20, 40);
      newBall.orbitSpeed = random(0.05, 0.1);
      newBall.orbitOffset = random(TWO_PI);
      orbitingBalls.push(newBall);
    }
    
    function checkBrickCollisions() {
      // Check all balls for brick collisions
      let allBalls = [mainBall, ...orbitingBalls];
      
      for (let i = bricks.length - 1; i >= 0; i--) {
        for (let ball of allBalls) {
          if (checkBallBrickCollision(ball, bricks[i])) {
            // Brick was hit
            bricks[i].hp--;
            score += 10;
            turns++;
            
            // If brick is destroyed, add an orbiting ball
            if (bricks[i].hp <= 0) {
              addOrbitingBall();
              bricks.splice(i, 1);
            }
            
            break; // Only count one hit per brick per frame
          }
        }
      }
    }
    
    function checkBallBrickCollision(ball, brick) {
      // Calculate distance between ball and brick
      let dx = ball.x - brick.x;
      let dy = ball.y - brick.y;
      let distance = sqrt(dx*dx + dy*dy);
      
      if (distance < ball.r + brick.r) {
        // Calculate collision angle for proper physics
        let angle = atan2(dy, dx);
        
        // Calculate normal vector of collision
        let nx = dx / distance;
        let ny = dy / distance;
        
        // Calculate dot product (ball's velocity projected onto normal)
        let dp = ball.dx * nx + ball.dy * ny;
        
        // Calculate reflection
        ball.dx = ball.dx - 2 * dp * nx;
        ball.dy = ball.dy - 2 * dp * ny;
        
        return true;
      }
      return false;
    }

    class Paddle {
      constructor() {
        this.w = 80;
        this.h = 10;
        this.x = width / 2 - this.w / 2;
        this.y = height - 30;
      }
      
      show() { 
        fill(255); 
        rect(this.x, this.y, this.w, this.h); 
      }
      
      move() {
        if (keyIsDown(LEFT_ARROW) && gameStarted && this.x > 0) this.x -= 5;
        if (keyIsDown(RIGHT_ARROW) && gameStarted && this.x < width - this.w) this.x += 5;
      }
    }

    class Ball {
      constructor(x = width / 2, y = height - 40, isOrbiting = false) {
        this.x = x;
        this.y = y;
        this.r = 10;
        this.dx = 0;
        this.dy = 0;
        this.isOrbiting = isOrbiting;
        this.isMain = false;
        
        // Orbiting properties
        if (isOrbiting) {
          this.orbitDistance = 30;
          this.orbitSpeed = 0.05;
          this.orbitOffset = 0;
        }
      }
      
      show() { 
        fill(255); // White ball
        ellipse(this.x, this.y, this.r * 2);
      }
      
      move() {
        if (this.isOrbiting && mainBall) {
          // Orbit around main ball
          let angle = frameCount * this.orbitSpeed + this.orbitOffset;
          this.x = mainBall.x + cos(angle) * this.orbitDistance;
          this.y = mainBall.y + sin(angle) * this.orbitDistance;
        } else {
          // Regular movement
          this.x += this.dx;
          this.y += this.dy;
        }
      }
      
      bounce() {
        // Wall bouncing
        if (this.x - this.r <= 0 || this.x + this.r >= width) {
          this.dx *= -1;
        }
        
        if (this.y - this.r <= 0) {
          this.dy *= -1;
        }
        
        // Paddle bouncing with physics
        if (this.y + this.r >= paddle.y && this.y < paddle.y + paddle.h && 
            this.x > paddle.x && this.x < paddle.x + paddle.w) {
          
          // Calculate bounce angle based on where ball hits paddle
          let relativeIntersect = (this.x - (paddle.x + paddle.w / 2)) / (paddle.w / 2);
          let bounceAngle = relativeIntersect * (PI/4); // Max 45 degree angle
          
          // Set new velocity
          let speed = sqrt(this.dx*this.dx + this.dy*this.dy);
          this.dx = sin(bounceAngle) * speed;
          this.dy = -cos(bounceAngle) * speed;
        }
        
        // Ball falls off bottom
        if (this.y - this.r > height) {
          if (this.isMain) {
            // Reset main ball
            gameStarted = false;
            this.dx = 0;
            this.dy = 0;
          } else if (this.isOrbiting) {
            // Remove orbiting ball
            orbitingBalls = orbitingBalls.filter(b => b !== this);
          }
        }
      }
    }
    
    class Brick {
      constructor(x, y, hp, type) {
        this.x = x;
        this.y = y;
        this.r = 15; // Radius for collision detection
        this.hp = hp;
        this.type = type;
      }
      
      show() {
        // Color based on brick type
        if (this.type === 'green') fill(0, 255, 0);
        else if (this.type === 'pink') fill(255, 0, 255);
        else fill(0, 0, 255);
        
        // Draw the circular brick
        ellipse(this.x, this.y, this.r * 2);
        
        // Draw hit points text
        fill(255);
        textAlign(CENTER, CENTER);
        textSize(12);
        text(this.hp, this.x, this.y);
        textAlign(LEFT);
      }
    }
  </script>
</body>
</html>
